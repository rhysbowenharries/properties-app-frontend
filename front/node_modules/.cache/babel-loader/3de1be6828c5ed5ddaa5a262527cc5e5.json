{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar core_1 = require(\"@aws-amplify/core\");\n\nvar logger = new core_1.ConsoleLogger('Predictions');\n\nvar Predictions =\n/** @class */\nfunction () {\n  /**\n   * Initialize Predictions with AWS configurations\n   * @param {PredictionsOptions} options - Configuration object for Predictions\n   */\n  function Predictions(options) {\n    this._options = options;\n    this._convertPluggables = [];\n    this._identifyPluggables = [];\n    this._interpretPluggables = [];\n  }\n\n  Predictions.prototype.getModuleName = function () {\n    return 'Predictions';\n  };\n  /**\n  * add plugin/pluggable into Predictions category\n  * @param {Object} pluggable - an instance of the plugin/pluggable\n  **/\n\n\n  Predictions.prototype.addPluggable = function (pluggable) {\n    if (this.getPluggable(pluggable.getProviderName())) {\n      throw new Error(\"Pluggable with name \" + pluggable.getProviderName() + \" has already been added.\");\n    }\n\n    var pluggableAdded = false;\n\n    if (this.implementsConvertPluggable(pluggable)) {\n      this._convertPluggables.push(pluggable);\n\n      pluggableAdded = true;\n    }\n\n    if (this.implementsIdentifyPluggable(pluggable)) {\n      this._identifyPluggables.push(pluggable);\n\n      pluggableAdded = true;\n    }\n\n    if (this.implementsInterpretPluggable(pluggable)) {\n      this._interpretPluggables.push(pluggable);\n\n      pluggableAdded = true;\n    }\n\n    if (pluggableAdded) {\n      this.configurePluggable(pluggable);\n    }\n  };\n  /**\n   * Get the plugin object\n   * @param providerName - the name of the plugin\n   */\n\n\n  Predictions.prototype.getPluggable = function (providerName) {\n    var pluggable = this.getAllProviders().find(function (pluggable) {\n      return pluggable.getProviderName() === providerName;\n    });\n\n    if (pluggable === undefined) {\n      logger.debug('No plugin found with providerName=>', providerName);\n      return null;\n    } else return pluggable;\n  };\n  /**\n   * Remove the plugin object\n   * @param providerName - the name of the plugin\n   */\n\n\n  Predictions.prototype.removePluggable = function (providerName) {\n    this._convertPluggables = this._convertPluggables.filter(function (pluggable) {\n      return pluggable.getProviderName() !== providerName;\n    });\n    this._identifyPluggables = this._identifyPluggables.filter(function (pluggable) {\n      return pluggable.getProviderName() !== providerName;\n    });\n    this._interpretPluggables = this._interpretPluggables.filter(function (pluggable) {\n      return pluggable.getProviderName() !== providerName;\n    });\n    return;\n  };\n  /**\n   * To make both top level providers and category level providers work with same interface and configuration\n   * this method duplicates Predictions config into parent level config (for top level provider) and\n   * category level config (such as convert, identify etc) and pass both to each provider.\n   */\n\n\n  Predictions.prototype.configure = function (options) {\n    var _this = this;\n\n    var predictionsConfig = options ? options.predictions || options : {};\n    predictionsConfig = __assign({}, predictionsConfig, options);\n    this._options = Object.assign({}, this._options, predictionsConfig);\n    logger.debug('configure Predictions', this._options);\n    this.getAllProviders().forEach(function (pluggable) {\n      return _this.configurePluggable(pluggable);\n    });\n  };\n\n  Predictions.prototype.interpret = function (input, options) {\n    var pluggableToExecute = this.getPluggableToExecute(this._interpretPluggables, options);\n    return pluggableToExecute.interpret(input);\n  };\n\n  Predictions.prototype.convert = function (input, options) {\n    var pluggableToExecute = this.getPluggableToExecute(this._convertPluggables, options);\n    return pluggableToExecute.convert(input);\n  };\n\n  Predictions.prototype.identify = function (input, options) {\n    var pluggableToExecute = this.getPluggableToExecute(this._identifyPluggables, options);\n    return pluggableToExecute.identify(input);\n  }; // tslint:disable-next-line: max-line-length\n\n\n  Predictions.prototype.getPluggableToExecute = function (pluggables, providerOptions) {\n    // Give preference to provider name first since it is more specific to this call, even if \n    // there is only one provider configured to error out if the name provided is not the one matched.\n    if (providerOptions && providerOptions.providerName) {\n      return pluggables.slice().find(function (pluggable) {\n        return pluggable.getProviderName() === providerOptions.providerName;\n      });\n    } else {\n      if (pluggables.length === 1) {\n        return pluggables[0];\n      } else {\n        throw new Error(\"More than one or no providers are configured, \" + \"Either specify a provider name or configure exactly one provider\");\n      }\n    }\n  };\n\n  Predictions.prototype.getAllProviders = function () {\n    return this._convertPluggables.concat(this._identifyPluggables, this._interpretPluggables);\n  };\n\n  Predictions.prototype.configurePluggable = function (pluggable) {\n    var categoryConfig = Object.assign({}, this._options['predictions'], // Parent predictions config for the top level provider\n    this._options[pluggable.getCategory().toLowerCase()] // Actual category level config\n    );\n    pluggable.configure(categoryConfig);\n  };\n\n  Predictions.prototype.implementsConvertPluggable = function (obj) {\n    return obj && typeof obj.convert === \"function\";\n  };\n\n  Predictions.prototype.implementsIdentifyPluggable = function (obj) {\n    return obj && typeof obj.identify === \"function\";\n  };\n\n  Predictions.prototype.implementsInterpretPluggable = function (obj) {\n    return obj && typeof obj.interpret === \"function\";\n  };\n\n  return Predictions;\n}();\n\nexports.default = Predictions;","map":null,"metadata":{},"sourceType":"script"}